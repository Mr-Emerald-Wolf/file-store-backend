// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: files.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFile = `-- name: CreateFile :one
INSERT INTO files (user_id, file_name, s3_url, file_size, file_type, is_public)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, file_name, s3_url, file_size, file_type, upload_date, last_accessed, is_public
`

type CreateFileParams struct {
	UserID   int32
	FileName string
	S3Url    pgtype.Text
	FileSize int64
	FileType pgtype.Text
	IsPublic pgtype.Bool
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.UserID,
		arg.FileName,
		arg.S3Url,
		arg.FileSize,
		arg.FileType,
		arg.IsPublic,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileName,
		&i.S3Url,
		&i.FileSize,
		&i.FileType,
		&i.UploadDate,
		&i.LastAccessed,
		&i.IsPublic,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = $1 AND user_id = $2
`

type DeleteFileParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) DeleteFile(ctx context.Context, arg DeleteFileParams) error {
	_, err := q.db.Exec(ctx, deleteFile, arg.ID, arg.UserID)
	return err
}

const deleteOldFiles = `-- name: DeleteOldFiles :exec
DELETE FROM files
WHERE created_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) DeleteOldFiles(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldFiles)
	return err
}

const getFileByID = `-- name: GetFileByID :one
SELECT id, user_id, file_name, s3_url, file_size, file_type, upload_date, last_accessed, is_public
FROM files
WHERE id = $1
`

func (q *Queries) GetFileByID(ctx context.Context, id int32) (File, error) {
	row := q.db.QueryRow(ctx, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileName,
		&i.S3Url,
		&i.FileSize,
		&i.FileType,
		&i.UploadDate,
		&i.LastAccessed,
		&i.IsPublic,
	)
	return i, err
}

const getFileByName = `-- name: GetFileByName :one
SELECT id, user_id, file_name, s3_url, file_size, file_type, upload_date, last_accessed, is_public
FROM files
WHERE file_name = $1
`

func (q *Queries) GetFileByName(ctx context.Context, fileName string) (File, error) {
	row := q.db.QueryRow(ctx, getFileByName, fileName)
	var i File
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileName,
		&i.S3Url,
		&i.FileSize,
		&i.FileType,
		&i.UploadDate,
		&i.LastAccessed,
		&i.IsPublic,
	)
	return i, err
}

const getFilesByUserID = `-- name: GetFilesByUserID :many
SELECT id, user_id, file_name, s3_url, file_size, file_type, upload_date, last_accessed, is_public
FROM files
WHERE user_id = $1
ORDER BY upload_date DESC
`

func (q *Queries) GetFilesByUserID(ctx context.Context, userID int32) ([]File, error) {
	rows, err := q.db.Query(ctx, getFilesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FileName,
			&i.S3Url,
			&i.FileSize,
			&i.FileType,
			&i.UploadDate,
			&i.LastAccessed,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFilesByDate = `-- name: SearchFilesByDate :many
SELECT id, user_id, file_name, s3_url, file_size, file_type, upload_date, last_accessed, is_public FROM files
WHERE user_id = $1 AND upload_date BETWEEN $2 AND $3
`

type SearchFilesByDateParams struct {
	UserID       int32
	UploadDate   pgtype.Timestamp
	UploadDate_2 pgtype.Timestamp
}

func (q *Queries) SearchFilesByDate(ctx context.Context, arg SearchFilesByDateParams) ([]File, error) {
	rows, err := q.db.Query(ctx, searchFilesByDate, arg.UserID, arg.UploadDate, arg.UploadDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FileName,
			&i.S3Url,
			&i.FileSize,
			&i.FileType,
			&i.UploadDate,
			&i.LastAccessed,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFilesByName = `-- name: SearchFilesByName :many
SELECT id, user_id, file_name, s3_url, file_size, file_type, upload_date, last_accessed, is_public FROM files
WHERE user_id = $1 AND file_name ILIKE '%' || $2 || '%'
`

type SearchFilesByNameParams struct {
	UserID  int32
	Column2 pgtype.Text
}

func (q *Queries) SearchFilesByName(ctx context.Context, arg SearchFilesByNameParams) ([]File, error) {
	rows, err := q.db.Query(ctx, searchFilesByName, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FileName,
			&i.S3Url,
			&i.FileSize,
			&i.FileType,
			&i.UploadDate,
			&i.LastAccessed,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFilesByType = `-- name: SearchFilesByType :many
SELECT id, user_id, file_name, s3_url, file_size, file_type, upload_date, last_accessed, is_public FROM files
WHERE user_id = $1 AND file_type ILIKE '%' || $2 || '%'
`

type SearchFilesByTypeParams struct {
	UserID  int32
	Column2 pgtype.Text
}

func (q *Queries) SearchFilesByType(ctx context.Context, arg SearchFilesByTypeParams) ([]File, error) {
	rows, err := q.db.Query(ctx, searchFilesByType, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FileName,
			&i.S3Url,
			&i.FileSize,
			&i.FileType,
			&i.UploadDate,
			&i.LastAccessed,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFile = `-- name: UpdateFile :one
UPDATE files
SET file_name = $1, last_accessed = NOW()
WHERE id = $2 AND user_id = $3
RETURNING id, user_id, file_name, s3_url, file_size, file_type, upload_date, last_accessed, is_public
`

type UpdateFileParams struct {
	FileName string
	ID       int32
	UserID   int32
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFile, arg.FileName, arg.ID, arg.UserID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileName,
		&i.S3Url,
		&i.FileSize,
		&i.FileType,
		&i.UploadDate,
		&i.LastAccessed,
		&i.IsPublic,
	)
	return i, err
}
